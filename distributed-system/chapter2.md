# 两将军问题

@2017.1.19



在计算机学科中，“两将军问题”是一个“思想实验”，其目的是为了展示仅依赖在一个不可靠的连接上进行通信来协调一个统一的行动所面临的挑战和缺陷。“两将军问题”与更加通用的“拜占庭将军”问题有关（虽然它比后者发表的时间要早得多），尽管“两将军问题”适用于所有可能出现通信错误的包含两方参与者的通信系统中，但是仍然常在关于计算机网络的入门课程中出现（特别是在传输控制协议中说明TCP无法保证不同节点之间状态的一致性及其原因）。从认识逻辑来看，这个问题强调了”共识“的重要性。有些作者也将其称为“两将军悖论”、“两军问题”或者“协同攻击问题”。“两将军问题”是第一个被证实为无法解决的计算机通信问题，证明的一个重要结论是推论出类似于“拜占庭将军问题“的问题在面临无法预知的通信错误时也都是无法解决的，从而为分布式一致性协议提供了切实可行的预测基础。

## 定义

有两支军队，分别由不同的将军率领，他们准备攻打一座具备防御工事的城市。军队驻扎在城市附近的两个不同的山谷中，这两个山谷被第三个山谷从中间给隔开。并且，两位将军之间唯一的通信方式是派遣信使穿过中间的山谷将消息传递给对方。但是，很不幸的是，中间的山谷被敌军占领了，并且所有穿过该山谷的传递消息的信使都可能被抓获。

![两将军问题](/resources/two-generals.png)

假设两位将军已经达成一致肯定会进攻，但是对于何时开始进攻尚未统一意见。为了或得胜利，我们要求两只军队必须在同时对这座城市发起进攻，如果两支部队各自为战则肯定会失败。因此两位将军必须互相通信决定开始进攻的时间，并且对在那个时间发动进攻达成一致。 每位将军都必须知道另一位将军一定已经知道他们两人已经对作战计划达成一致。由于消息接收方的响应消息和原始消息一样可能丢失，因此这里就隐藏了一个限制条件：为了达成一致，必须永不停歇的向对方发送消息。

这个思想实验包括考虑他们可能如何达成一致的过程。在"两将军问题"最简单的形式中，其中一位将军是Leader身份，他来决定进攻的时间，并且必须将这个时间传达给另一位将军。这个问题引出将军可以使用的算法，包括：发送消息和处理回执消息，从而使他们可以正确的得到如下结论：

> 是的，我们两支军队将在协商好的时间同时发起进攻。

只要承认上面的结论，那么将军们对进攻时间达成一致就非常简单了（比如，一条成功的消息和一条成功的回执）。但是"两将军问题"的精妙之处就在于无法为将军们设计出这样的算法来达成上述协议。



## 问题

第一个将军可能发送一条消息"在8月4日早晨 9点发起进攻"。但是，一点消息分发出去，第一个将军就没法知道消息是不是成功的通过了中间的山谷。这种不确定性可能导致第一个将军由于担心自己成为单一攻击者的风险而对进攻犹豫不决。

如果确认消息送达，第二个将军可能向第一个将军发送一条确认消息："我收到了你的消息，并且将在8月4日早晨9点发起进攻"。但是，携带确认消息的信使可能被敌军抓获，这样第二个将军也会犹豫，因为他知道第一个将军可能因为没有收到确认信息而中止进攻。

进一步的确认消息看上去像是一个解决方案，让第一个将军向第二个将军发送一个二次确认消息："我已经收到你对在8月4日早晨9点发起进攻的确认回执了"。但是，第一位将军派遣的新的信使也可能被敌军抓获。因此，我们很快就可以得出结论，无论发起多少轮的消息确认，也无法保证第二个必要条件成立：每个将军都确认对方已经同意了进攻计划。

两个将军总是处于等待其最后一条消息是否通过敌军山谷的焦虑中。

## 证明

### 具有固定消息数量的确定性协议

因为协议是确定性的，假设有一个固定数量的消息序列，其中有一条或者多条消息成功送达，也有一条或者多条消息没有成功送达。假定两位将军之间有一个共享的发起进攻的决议。

考虑最后一条消息被成功的投递。

如果最后一条消息没有成功投递，那么至少有一位将军（可能是接收者）将会决定不发起进攻。从最后一条消息的发送方视角来看，消息的发送和投递序列与成功投递的消息序列是完全一致的。

由于协议是确定性的，发送最后一条消息的将军仍然会发起进攻。我们现在已经创建了一种情况，建议的协议导致一个将军发起进攻而另一个将军却不进攻，这就与假定该协议可以解决这个问题自相矛盾了。

### 非确定性变长协议

一个带有变化的消息数量的非确定性协议可以比拟成一个"有限森林"，森林中的每个叶子或者分支（节点）代表截止某个点为止已经发现的示例。

森林的根用不同的初始消息标识，从这些根节点衍生的分支节点用初始消息的下一条消息标识。叶子节点代表发送最后一条消息之后的示例。在发送任何消息之前就终止的消息用一个空的森林表示。

假设存在一个可以解决“两将军问题”的非确定协议，那么通过移除森林中某棵树所有叶子节点后得到的确定性的示例也可以解决这个问题。

由于非确定协议是有限的，但是它又允许由一个空的森林表示的协议来解决“两将军问题"，很明显这是不可能的。因此也不存在可以解决"两将军问题"的非确定性协议。

## 工程实践

对“两将军问题”进行编程处理，不能试图消除通信信道的不确定性，而应该将不确定性降到到可接受的程度。比如，第一个将军可以派遣出100个信使，并且预计100人全部被抓的概率很低。基于这种方式，第一个将军无论如何都将发起进攻，而第二个将军只要收到消息也会发起进攻。替代方案是第一个将军发送一个消息流，第二个将军可以对其收到的消息流逐个发送确认消息。每收到一条消息将军们都会感到更加有信心。正如证明中看到的，没人可以确认进攻肯定可以被协调好。没有算法（例如，如果收到4条以上的消息就发起进攻）可以保证不出现只有一方发起进攻的情况。当然，第一位将军可以在每条消息上增加一个标识，表示这条消息的次序1，2，3…..n。这个方法让发送消息的将军可以知道消息通道的可靠性，然后发送满足一定数量要求的消息给接收者，来确保接收者至少接收到一条消息的概率很高。如果通道被认为是可靠的，那么一条消息就足够了，多余的消息也于事无补。最后一条很可能像第一条一样丢失。

 假设每当派遣出去的信使被截获时，将军们都必须派遣一名新的信使，可以设计一个算法用最少的信使就可以保证或得协调进攻所需的足够高的信心。为了达到这个目的，将军们可以同意将信使的消失作为发起消息的将军至少已经接收到了一条回执消息的标识，并且保证会发动进攻。假设一个信使通过危险区域需要花费1分钟，在收到回执消息之后允许200分钟的静默期可以使我们无需派遣更多的信使就能得到很高的信心。这种情况下，信使仅在一方未接收到进攻时间时使用。当200分钟静默期结束时，每个将军都可以推断：我已经有200分钟没有接收到消息了，要么是这期间的200个信使都没能闯过危险区，要么意味着对方已经确认并保证会发起进攻，那么我也一样需要这样做。”

## 历史

两将军问题及其无解的证明首次出现在由E.A.Akkoyunlu,K.Ekannadham,和R.V.Huber于1975年发表的论文“网络通信设计中的一些限制与妥协”中，在关于两组匪徒通信的上下文环境中从第73页开始描述。

 这个问题被JimGray在1978年发表的“数据库操作系统比较”第465页中命名为“两将军悖论”。这也是被广泛引用的关于这个问题的定义和误解证明的来源，虽然发表时间并不是最早的。



## 附录

[Tow generals]([https://en.wikipedia.org/wiki/Two_Generals%27_Problem](https://en.wikipedia.org/wiki/Two_Generals%27_Problem))
